<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://oppkey.github.io/fastopp/feed.xml" rel="self" type="application/atom+xml" /><link href="https://oppkey.github.io/fastopp/" rel="alternate" type="text/html" /><updated>2025-10-07T23:20:41+00:00</updated><id>https://oppkey.github.io/fastopp/feed.xml</id><title type="html">FastOpp Blog</title><subtitle>Easier AI Web Apps for Students - FastAPI starter package for students prototyping AI web applications</subtitle><author><name>Oppkey</name></author><entry><title type="html">Architectural Consistency When Working with a PostgreSQL Async Database</title><link href="https://oppkey.github.io/fastopp/2025/10/07/postgresql-async/" rel="alternate" type="text/html" title="Architectural Consistency When Working with a PostgreSQL Async Database" /><published>2025-10-07T00:00:00+00:00</published><updated>2025-10-07T00:00:00+00:00</updated><id>https://oppkey.github.io/fastopp/2025/10/07/postgresql-async</id><content type="html" xml:base="https://oppkey.github.io/fastopp/2025/10/07/postgresql-async/"><![CDATA[<h2 id="postgresql-failing-with-async-in-production-although-sqlite-works-on-my-mac">PostgreSQL Failing with Async in Production Although SQLite Works on my Mac</h2>

<p>Last week, I was working on our FastOpp project and ran into a classic developer problem: “It works on my machine, but not in production.” Specifically, our FastAPI application worked perfectly with SQLite during development, but when I tried to switch to PostgreSQL in production on Leapcell using the Leapcell PostgreSQL service,
database access broke.</p>

<h2 id="converting-database-connection-to-sync-led-to-more-problems">Converting Database Connection to Sync Led to More Problems</h2>

<p>My first instinct was the same as many developers: find a workaround. I discovered that our
migration tool (Alembic) was trying to use synchronous database operations while our
FastAPI app was using asynchronous ones.</p>

<p>The “solution” I found online was to convert the database URL from async to sync during migrations:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The "quick fix" approach - BEFORE
</span><span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">database_url</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">"DATABASE_URL"</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">get_main_option</span><span class="p">(</span><span class="s">"sqlalchemy.url"</span><span class="p">))</span>
    
    <span class="c1"># Convert async URLs to regular URLs for migrations
</span>    <span class="k">if</span> <span class="n">database_url</span> <span class="ow">and</span> <span class="s">"aiosqlite"</span> <span class="ow">in</span> <span class="n">database_url</span><span class="p">:</span>
        <span class="n">database_url</span> <span class="o">=</span> <span class="n">database_url</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">"sqlite+aiosqlite://"</span><span class="p">,</span> <span class="s">"sqlite://"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">database_url</span> <span class="ow">and</span> <span class="s">"asyncpg"</span> <span class="ow">in</span> <span class="n">database_url</span><span class="p">:</span>
        <span class="n">database_url</span> <span class="o">=</span> <span class="n">database_url</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">"postgresql+asyncpg://"</span><span class="p">,</span> <span class="s">"postgresql://"</span><span class="p">)</span>
    
    <span class="n">connectable</span> <span class="o">=</span> <span class="n">engine_from_config</span><span class="p">(...)</span>  <span class="c1"># SYNC engine
</span>    <span class="k">with</span> <span class="n">connectable</span><span class="p">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>  <span class="c1"># SYNC connection
</span>        <span class="n">context</span><span class="p">.</span><span class="n">configure</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>

<p>I committed the solution after only testing it on SQLite locally and unfortunately forgot
to test it on PostgreSQL.  Several months passed and my laziness came back to bite
me and cost me many hours. As I am new to Alembic, I didn’t think about
async Alembic patterns. The logic of using synchronous calls for migrations seemed fine
to me as migrations <em>felt</em> synchronous.  I didn’t think about this mismatch in architectures
too deeply, shrugging it off as “the way things are.”</p>

<h2 id="the-real-problem-architectural-mismatch">The Real Problem: Architectural Mismatch</h2>

<p>Here’s what I learned: when you build an async application, try to keep as much of your code
as possible async. Although it is possible to “convert” async to sync in the middle of your stack,
it may cause problems in the future when you have to maintain your own code.</p>

<p>The issue wasn’t with the database or the migration tool. The issue was that I was trying to mix two different paradigms:</p>

<ul>
  <li><strong>My FastAPI app</strong>: Async throughout (using <code class="language-plaintext highlighter-rouge">asyncpg</code> for PostgreSQL)</li>
  <li><strong>My migrations</strong>: Sync operations (using sync database drivers)</li>
</ul>

<h2 id="the-right-solution-go-all-in-on-async">The Right Solution: Go All-In on Async</h2>

<p>Instead of trying to convert between async and sync, I updated our migration system to be async from the ground up. Here’s the transformation:</p>

<h2 id="the-solution-pure-async-approach">The Solution: Pure Async Approach</h2>

<p>The key was updating <code class="language-plaintext highlighter-rouge">alembic/env.py</code> to use async patterns throughout:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The RIGHT approach - AFTER
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.ext.asyncio</span> <span class="kn">import</span> <span class="n">async_engine_from_config</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.engine</span> <span class="kn">import</span> <span class="n">Connection</span>

<span class="k">def</span> <span class="nf">do_run_migrations</span><span class="p">(</span><span class="n">connection</span><span class="p">:</span> <span class="n">Connection</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">context</span><span class="p">.</span><span class="n">configure</span><span class="p">(</span><span class="n">connection</span><span class="o">=</span><span class="n">connection</span><span class="p">,</span> <span class="n">target_metadata</span><span class="o">=</span><span class="n">target_metadata</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">context</span><span class="p">.</span><span class="n">begin_transaction</span><span class="p">():</span>
        <span class="n">context</span><span class="p">.</span><span class="n">run_migrations</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">run_async_migrations</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">connectable</span> <span class="o">=</span> <span class="n">async_engine_from_config</span><span class="p">(...)</span>  <span class="c1"># ASYNC engine
</span>    <span class="k">async</span> <span class="k">with</span> <span class="n">connectable</span><span class="p">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>  <span class="c1"># ASYNC connection
</span>        <span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">run_sync</span><span class="p">(</span><span class="n">do_run_migrations</span><span class="p">)</span>  <span class="c1"># Magic happens here!
</span>    <span class="k">await</span> <span class="n">connectable</span><span class="p">.</span><span class="n">dispose</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">run_migrations_online</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_async_migrations</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="technical-implementation-details">Technical Implementation Details</h3>

<ul>
  <li><strong>Added async imports</strong>: <code class="language-plaintext highlighter-rouge">asyncio</code>, <code class="language-plaintext highlighter-rouge">Connection</code>, <code class="language-plaintext highlighter-rouge">async_engine_from_config</code></li>
  <li><strong>Replaced sync patterns</strong> with async alembic template approach</li>
  <li><strong>Added <code class="language-plaintext highlighter-rouge">do_run_migrations()</code></strong> function for connection handling</li>
  <li><strong>Added <code class="language-plaintext highlighter-rouge">run_async_migrations()</code></strong> function for async engine management</li>
  <li><strong>Updated <code class="language-plaintext highlighter-rouge">run_migrations_online()</code></strong> to use <code class="language-plaintext highlighter-rouge">asyncio.run()</code></li>
</ul>

<p>The key insight was this line:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="n">connection</span><span class="p">.</span><span class="n">run_sync</span><span class="p">(</span><span class="n">do_run_migrations</span><span class="p">)</span>
</code></pre></div></div>

<p>This allows you to run synchronous migration code within an async database connection.</p>

<h2 id="the-results-what-actually-happened">The Results: What Actually Happened</h2>

<p>After implementing the async approach, here’s what we achieved:</p>

<h3 id="single-driver-architecture"><strong>Single Driver Architecture</strong></h3>

<ul>
  <li><strong>Before</strong>: Needed both <code class="language-plaintext highlighter-rouge">asyncpg</code> (app) + <code class="language-plaintext highlighter-rouge">psycopg2</code> (migrations)</li>
  <li><strong>After</strong>: Only <code class="language-plaintext highlighter-rouge">asyncpg</code> for everything - no driver conflicts</li>
</ul>

<h3 id="consistent-database-urls"><strong>Consistent Database URLs</strong></h3>

<ul>
  <li><strong>Before</strong>: App used <code class="language-plaintext highlighter-rouge">postgresql+asyncpg://</code> but migrations converted to <code class="language-plaintext highlighter-rouge">postgresql://</code></li>
  <li><strong>After</strong>: Both use <code class="language-plaintext highlighter-rouge">postgresql+asyncpg://</code> - same driver throughout</li>
</ul>

<h3 id="works-with-both-databases"><strong>Works with Both Databases</strong></h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SQLite (development)</span>
<span class="nb">export </span><span class="nv">DATABASE_URL</span><span class="o">=</span><span class="s2">"sqlite+aiosqlite:///./test.db"</span>
uv run python oppman.py migrate upgrade  <span class="c"># ✅ Works</span>
uv run python oppman.py runserver  <span class="c"># ✅ Works</span>

<span class="c"># PostgreSQL (production)  </span>
<span class="nb">export </span><span class="nv">DATABASE_URL</span><span class="o">=</span><span class="s2">"postgresql+asyncpg://user@localhost:5432/fastopp"</span>
uv run python oppman.py migrate upgrade  <span class="c"># ✅ Works</span>
uv run python oppman.py runserver  <span class="c"># ✅ Works</span>
</code></pre></div></div>

<h3 id="database-verification-results"><strong>Database Verification Results</strong></h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># PostgreSQL tables created successfully</span>
psql <span class="nt">-d</span> fastopp_test <span class="nt">-c</span> <span class="s2">"</span><span class="se">\d</span><span class="s2">t"</span>
<span class="c"># Result: users, products, webinar_registrants, audit_logs, alembic_version</span>

<span class="c"># Health check verification</span>
curl <span class="nt">-s</span> http://localhost:8000/health
<span class="c"># Result: {"status":"healthy","message":"FastOpp Demo app is running"}</span>
</code></pre></div></div>

<h2 id="benefits-of-the-async-approach">Benefits of the Async Approach</h2>

<h3 id="performance-benefits">Performance Benefits</h3>

<ul>
  <li><strong>Async operations</strong> throughout the application</li>
  <li><strong>No sync/async context switching</strong> overhead</li>
  <li><strong>Better concurrency</strong> for database operations</li>
</ul>

<h3 id="developer-experience">Developer Experience</h3>

<ul>
  <li><strong>Single driver approach</strong> - no psycopg2 conflicts</li>
  <li><strong>Environment-based switching</strong> between SQLite and PostgreSQL</li>
  <li><strong>Modern async patterns</strong> following SQLAlchemy 2.0 best practices</li>
</ul>

<h3 id="production-ready">Production Ready</h3>

<ul>
  <li><strong>PostgreSQL support</strong> for production deployments</li>
  <li><strong>Async alembic migrations</strong> work with both databases</li>
  <li><strong>No breaking changes</strong> to existing SQLite development workflow</li>
</ul>

<h2 id="why-this-matters-for-students">Why This Matters for Students</h2>

<p>If you’re learning web development, here’s the takeaway: <strong>consistency is more important than clever workarounds</strong>.</p>

<p>When you’re building modern web applications:</p>

<ul>
  <li>Choose your architecture (sync or async) and stick with it</li>
  <li>Don’t try to mix paradigms just because it seems easier</li>
  <li>The “quick fix” often becomes the “long-term problem”</li>
</ul>

<h2 id="async-database-access-may-not-be-justified">Async Database Access May Not Be Justified</h2>

<p>Standardizing on synchronous database access for everything is simpler and will
work for most apps.  Asynchronous operations are needed only for heavy
SQL joins where the response takes many seconds or minutes and need to be run
in real-time.  In most cases, people will run the operation in the background
with Celery.</p>

<p>However, even if I don’t see the need for asynchronous database connections,
other people might.  FastOpp is a learning tool and I want to provide
asynchronous connectivity to support the creativity of others.</p>

<h2 id="the-business-lesson">The Business Lesson</h2>

<p>As a manager, I’ve seen this pattern play out in many projects. The “quick fix”
that saves 30 minutes today often costs hours or days later. In this case, spending the extra time to properly implement async migrations saved us from a maintenance nightmare. The “quick fix”
was also forgotten because there is no real-world impact in using synchronous migrations.</p>

<p>The modern approach - using async patterns throughout - is not just technically correct, it’s also more maintainable and scalable.</p>

<h2 id="whats-next">What’s Next</h2>

<p>Our FastOpp project now supports both SQLite (for development) and PostgreSQL (for production) with a single, consistent async architecture. No more driver conflicts, no more sync/async mixing, and no more “it works on my machine” problems.</p>

<p>It appears that <a href="https://www.psycopg.org/psycopg3/">psycopg3</a> supports both async and sync. I don’t think it’s as popular
as asyncpg.  However, I hope to try it out next.</p>

<h2 id="migration-guide-for-existing-users">Migration Guide for Existing Users</h2>

<h3 id="no-action-required"><strong>No Action Required</strong></h3>

<ul>
  <li><strong>SQLite development</strong> continues to work exactly as before</li>
  <li><strong>Optional</strong>: Update <code class="language-plaintext highlighter-rouge">.env</code> to use <code class="language-plaintext highlighter-rouge">sqlite+aiosqlite://</code> for consistency</li>
  <li><strong>For PostgreSQL testing</strong>: Set <code class="language-plaintext highlighter-rouge">DATABASE_URL=postgresql+asyncpg://...</code></li>
</ul>

<h3 id="for-new-deployments"><strong>For New Deployments</strong></h3>

<ol>
  <li><strong>Development</strong>: Use <code class="language-plaintext highlighter-rouge">DATABASE_URL=sqlite+aiosqlite:///./test.db</code></li>
  <li><strong>Production</strong>: Use <code class="language-plaintext highlighter-rouge">DATABASE_URL=postgresql+asyncpg://user:pass@host:port/db</code></li>
  <li><strong>Run migrations</strong>: <code class="language-plaintext highlighter-rouge">uv run python oppman.py migrate upgrade</code></li>
</ol>

<h2 id="files-changed">Files Changed</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">alembic/env.py</code> - Updated to async patterns</li>
  <li><code class="language-plaintext highlighter-rouge">example.env</code> - Added PostgreSQL configuration examples</li>
  <li><code class="language-plaintext highlighter-rouge">docs/deployment/POSTGRESQL_SETUP.md</code> - Updated installation instructions</li>
  <li><code class="language-plaintext highlighter-rouge">docs/DATABASE.md</code> - Updated troubleshooting with async patterns</li>
</ul>

<h2 id="breaking-changes">Breaking Changes</h2>

<p><strong>None</strong> - This is a backward-compatible enhancement that adds PostgreSQL support while maintaining full SQLite compatibility.</p>

<h2 id="additional-information">Additional Information</h2>

<p><a href="https://github.com/Oppkey/fastopp/pull/140">Pull request with extensive description of changes</a>.</p>]]></content><author><name>Craig Oda</name></author><summary type="html"><![CDATA[How I learned that async databases need async migrations, and why the 'quick fix' approach doesn't scale]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://oppkey.github.io/fastopp/assets/images/2025_10/run.jpg" /><media:content medium="image" url="https://oppkey.github.io/fastopp/assets/images/2025_10/run.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Using Tavily to add internet search to chat</title><link href="https://oppkey.github.io/fastopp/2025/09/30/adding-internet-search-to-llm/" rel="alternate" type="text/html" title="Using Tavily to add internet search to chat" /><published>2025-09-30T00:00:00+00:00</published><updated>2025-09-30T00:00:00+00:00</updated><id>https://oppkey.github.io/fastopp/2025/09/30/adding-internet-search-to-llm</id><content type="html" xml:base="https://oppkey.github.io/fastopp/2025/09/30/adding-internet-search-to-llm/"><![CDATA[<h3 id="httpsgithubcomcodetricitychat-with-history"><a href="https://github.com/codetricity/chat-with-history">https://github.com/codetricity/chat-with-history</a></h3>]]></content><author><name>Shotoku</name></author><summary type="html"><![CDATA[This chat_with_history example has an a way to connect LLM to internet search]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://oppkey.github.io/fastopp/assets/images/search-icon.png" /><media:content medium="image" url="https://oppkey.github.io/fastopp/assets/images/search-icon.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">FastOpp Deployment to Leapcell - Free Hosting Tier</title><link href="https://oppkey.github.io/fastopp/2025/09/30/leapcell-deployment/" rel="alternate" type="text/html" title="FastOpp Deployment to Leapcell - Free Hosting Tier" /><published>2025-09-30T00:00:00+00:00</published><updated>2025-09-30T00:00:00+00:00</updated><id>https://oppkey.github.io/fastopp/2025/09/30/leapcell-deployment</id><content type="html" xml:base="https://oppkey.github.io/fastopp/2025/09/30/leapcell-deployment/"><![CDATA[<p>These tutorials will take you through free deployment on
Leapcell with both FastAPI and FastOpp.</p>

<p><a href="https://youtu.be/xhOALd640tA">FastAPI Deploy to Leapcell - free hosting tier</a></p>

<p><a href="https://youtu.be/GoKpQTHE-1A">Free  Deploy to Leapcell with FastAPI, PostgreSQL and Object Storage</a></p>]]></content><author><name>Oppkey Tutor</name></author><summary type="html"><![CDATA[Free deployment to Leapcell. No credit card required.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://oppkey.github.io/fastopp/assets/images/leapcell_logo.png" /><media:content medium="image" url="https://oppkey.github.io/fastopp/assets/images/leapcell_logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Our Process for Testing and Contributing to FastOpp</title><link href="https://oppkey.github.io/fastopp/2025/09/30/testing-fastopp/" rel="alternate" type="text/html" title="Our Process for Testing and Contributing to FastOpp" /><published>2025-09-30T00:00:00+00:00</published><updated>2025-09-30T00:00:00+00:00</updated><id>https://oppkey.github.io/fastopp/2025/09/30/testing-fastopp</id><content type="html" xml:base="https://oppkey.github.io/fastopp/2025/09/30/testing-fastopp/"><![CDATA[<p>Testing …</p>

<p>Ipsum lorem…</p>]]></content><author><name>Ethan Luke Kim</name></author><summary type="html"><![CDATA[A quick guide and personal notes on testing the FastOpp framework, including the essential git commands for contributing.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://oppkey.github.io/fastopp/assets/images/github-pull-request.webp" /><media:content medium="image" url="https://oppkey.github.io/fastopp/assets/images/github-pull-request.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Welcome to FastOpp - Easier AI Web Apps for Students</title><link href="https://oppkey.github.io/fastopp/2025/09/29/welcome-to-fastopp/" rel="alternate" type="text/html" title="Welcome to FastOpp - Easier AI Web Apps for Students" /><published>2025-09-29T00:00:00+00:00</published><updated>2025-09-29T00:00:00+00:00</updated><id>https://oppkey.github.io/fastopp/2025/09/29/welcome-to-fastopp</id><content type="html" xml:base="https://oppkey.github.io/fastopp/2025/09/29/welcome-to-fastopp/"><![CDATA[<p>Welcome to the FastOpp blog. <strong>FastOpp</strong> is a FastAPI starter package designed specifically for students prototyping AI web applications.</p>

<h2 id="what-is-fastopp">What is FastOpp?</h2>

<p>FastOpp provides pre-built admin components that give FastAPI functionality comparable to Django for AI-first applications. It’s designed to bridge the gap between Django’s ease of use and FastAPI’s modern async capabilities.</p>

<h3 id="the-problem-were-solving">The Problem We’re Solving</h3>

<p>Django and Flask are not designed for optimized async LLM applications. While both can absolutely be used for complex AI applications, there are often rough patches during development of asynchronous AI applications that communicate with backend LLMs available at OpenAI, Anthropic, and OpenRouter.</p>

<p>FastAPI has advantages in future-proof architecture, but can have a steep learning curve for people, especially for developers familiar with Django. FastOpp bridges this gap by providing an opinionated framework for FastAPI with Django-inspired features.</p>

<h2 id="key-features">Key Features</h2>

<h3 id="️-admin-panel">🛡️ Admin Panel</h3>
<p>Django-style admin panel with role-based authentication, similar to Django admin but built for FastAPI.</p>

<h3 id="️-sql-database">🗄️ SQL Database</h3>
<p>SQL database with Django-inspired models and migrations using SQLModel and Alembic.</p>

<h3 id="-modern-ui">🎨 Modern UI</h3>
<p>Tailwind CSS, DaisyUI, Alpine.js, and HTMX for beautiful, interactive interfaces.</p>

<h3 id="-api-endpoints">🔌 API Endpoints</h3>
<p>Auto-generated API documentation and endpoints designed to connect with React and Flutter.</p>

<h3 id="-fast-development">⚡ Fast Development</h3>
<p>Get started quickly with pre-built components and management tools like <code class="language-plaintext highlighter-rouge">oppman.py</code> and <code class="language-plaintext highlighter-rouge">oppdemo.py</code>.</p>

<h2 id="who-is-fastopp-for">Who is FastOpp For?</h2>

<p>FastOpp is opinionated and may not be for everyone. It’s intended for:</p>

<ul>
  <li><strong>University students</strong> looking to build resume projects</li>
  <li><strong>Hobbyists</strong> wanting to vibe code simple AI utilities</li>
  <li><strong>Small business entrepreneurs</strong> with great ideas but limited programming experience</li>
</ul>

<h3 id="important-note">Important Note</h3>
<p>FastOpp is <strong>not intended for production use or for experienced developers</strong>. It’s a learning tool designed to get you started quickly with AI applications.</p>

<h2 id="quick-start">Quick Start</h2>

<p>Getting started with FastOpp is simple:</p>

<ol>
  <li><strong>Create your repo from the template</strong>
    <ul>
      <li>Go to <a href="https://github.com/Oppkey/FastOpp">FastOpp on GitHub</a></li>
      <li>Click “Use this template” → “Create a new repository”</li>
      <li>Name it (e.g., <code class="language-plaintext highlighter-rouge">fastopp-&lt;yourproject&gt;</code>)</li>
    </ul>
  </li>
  <li><strong>Clone and setup</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/&lt;YOUR_USERNAME&gt;/fastopp-&lt;yourproject&gt;.git
<span class="nb">cd </span>fastopp-&lt;yourproject&gt;
uv <span class="nb">sync</span>
</code></pre></div>    </div>
  </li>
  <li><strong>One-command setup</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uv run python oppdemo.py init
</code></pre></div>    </div>
  </li>
  <li><strong>Start developing</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uv run python oppman.py runserver
</code></pre></div>    </div>
  </li>
</ol>

<p>Visit <code class="language-plaintext highlighter-rouge">http://localhost:8000/</code> to see your FastOpp application in action!</p>

<h2 id="whats-next">What’s Next?</h2>

<p>In upcoming posts, I’ll cover:</p>

<ul>
  <li>Setting up your first AI chat application</li>
  <li>Customizing the admin panel</li>
  <li>Deploying to production</li>
  <li>Advanced FastAPI patterns with FastOpp</li>
</ul>

<h2 id="get-involved">Get Involved</h2>

<ul>
  <li><strong>GitHub</strong>: <a href="https://github.com/Oppkey/FastOpp">Oppkey/FastOpp</a></li>
  <li><strong>Issues</strong>: Report bugs or request features</li>
  <li><strong>Discussions</strong>: Ask questions and share your projects</li>
</ul>

<p>FastOpp is designed to be beautiful, cheap, easy, and opinionated. Whether you’re a student building your first AI app or a hobbyist exploring new possibilities, FastOpp provides the foundation you need to get started quickly.</p>

<p>Stay tuned for more tutorials, tips, and updates about FastOpp development!</p>

<hr />

<p><em>Have questions about FastOpp? Check out our <a href="https://github.com/Oppkey/FastOpp">GitHub repository</a> or start a discussion. We’d love to hear about your AI application ideas!</em></p>]]></content><author><name>Craig Oda</name></author><summary type="html"><![CDATA[Introducing FastOpp, a FastAPI starter package designed for students prototyping AI web applications. Get Django-like functionality with FastAPI's async capabilities.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://oppkey.github.io/fastopp/assets/images/workshop.webp" /><media:content medium="image" url="https://oppkey.github.io/fastopp/assets/images/workshop.webp" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>